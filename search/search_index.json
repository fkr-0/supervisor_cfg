{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":""},{"location":"#supervisor-cfg","title":"supervisor-cfg","text":""},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Introduction</li> <li>Installation</li> <li>Features</li> <li>Usage</li> <li>Exposed Methods</li> <li>Contribution</li> <li>Acknowledgments</li> <li>License</li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p><code>supervisor-cfg</code> is a Supervisor plugin designed to provide functionalities for persistent manipulation of Supervisor's configuration file using supervisors xml-rpc interface. The design of this project is closely following the design of the supervisor_twiddler plugin. ~~Docs.~~</p>"},{"location":"#todo","title":"Todo","text":"<ul> <li><code>Usage</code> docs</li> <li>Also allow using conf dir as \"backend\" for config file</li> <li>more Tests</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>~~Follow the standard Supervisor plugin installation guidelines.~~</p> <p>This project is not yet available on PyPI. You can install it by cloning the repository and running <code>pip install .</code> in the root directory.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Get and set the Supervisor configuration file.</li> <li>Whitelist functionalities.</li> <li>Modify specific sections or commands for Supervisor programs and persist the changes.</li> </ul>"},{"location":"#usage","title":"Usage","text":""},{"location":"#todo_1","title":"TODO","text":""},{"location":"#contribution","title":"Contribution","text":"<p>If you would like to contribute to this Supervisor plugin, please feel free to submit a pull request, create an issue, or fork the repository.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<ul> <li>Thanks to the Supervisor project for a great daemon manager.</li> <li>Thanks to the supervisor_twiddler plugin for inspiration.</li> <li>Anyone whose code was used.</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License</p> <pre><code>The MIT License (MIT)\n\nCopyright (c) 2023\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"rpcinterface_reference/","title":"Reference","text":""},{"location":"rpcinterface_reference/#supervisor_cfg.rpcinterface.CfgNamespaceRPCInterface","title":"<code>CfgNamespaceRPCInterface</code>","text":"<p>An RPC interface for managing Supervisor's configuration.</p> <p>Attributes:</p> Name Type Description <code>supervisord</code> <p>The Supervisor daemon instance.</p> <code>_whitelist</code> <code>List[str]</code> <p>List of whitelisted function names.</p> Source code in <code>supervisor_cfg/rpcinterface.py</code> <pre><code>class CfgNamespaceRPCInterface:\n\"\"\"\n    An RPC interface for managing Supervisor's configuration.\n    Attributes:\n        supervisord: The Supervisor daemon instance.\n        _whitelist (List[str]): List of whitelisted function names.\n    \"\"\"\ndef __init__(self, supervisord, whitelist: list[str] = []) -&gt; None:\n\"\"\"\n        Initializes the CfgNamespaceRPCInterface class.\n        Args:\n            supervisord: Supervisor daemon instance.\n            whitelist (List[str], optional): List of whitelisted\n                function names. Defaults to empty list.\n        Raises:\n            TypeError: Raised if whitelist is not a list of strings.\n        \"\"\"\nself.supervisord = supervisord\nself._whitelist = list_of_strings(whitelist)\ndef _update(self, func_name: str) -&gt; None:\n\"\"\"\n        Updates the internal state for a specific function call.\n        Args:\n            func_name (str): Name of the function being invoked.\n        Raises:\n            RPCError: Raised if the system is in SHUTDOWN state.\n            RPCError: Raised if function name is not in the whitelist.\n        \"\"\"\nself.update_text = func_name\nstate = self.supervisord.get_state()\nif state == SupervisorStates.SHUTDOWN:\nraise RPCError(SupervisorFaults.SHUTDOWN_STATE)\nif len(self._whitelist):\nif func_name not in self._whitelist:\nraise RPCError(ExtendedSupervisorStates.NOT_IN_WHITELIST, func_name)\n# RPC API methods\ndef _config_filename(self) -&gt; str:\n\"\"\"\n        Retrieves the absolute path of the configuration file.\n        Returns:\n            str: Absolute path of the configuration file.\n        \"\"\"\nreturn os.path.abspath(self.supervisord.options.configfile)\ndef get_config_filename(self) -&gt; str:\n\"\"\"\n        Retrieves the absolute path of the configuration file.\n        Returns:\n            str: Absolute path of the configuration file.\n        \"\"\"\nself._update(\"get_config_filename\")\nreturn self._config_filename()\ndef _config_file_parser(self) -&gt; UnhosedConfigParser:\n\"\"\"\n        Parses the configuration file and returns its content.\n        Returns:\n            UnhosedConfigParser: Object representing the parsed\n                content of the configuration file.\n        \"\"\"\nconfig = UnhosedConfigParser(interpolation=None)\nconfig.read(self._config_filename())\nreturn config\ndef _config_file_dict(self) -&gt; dict[str, dict[str, str]]:\n\"\"\"\n        Converts the parsed configuration file into a dictionary.\n        Returns:\n            Dict[str, Dict[str, str]]: Dictionary representation\n                of the configuration file.\n        \"\"\"\nreturn {x: dict(y) for x, y in dict(self._config_file_parser()).items()}\ndef _set_command(\nself, program: str, command: str\n) -&gt; tuple[list[str], list[str], list[str]]:\n\"\"\"\n        Sets the command for a specified program in the configuration file.\n        Args:\n            program (str): Name of the program.\n            command (str): The command to set for the program.\n        Returns:\n            Tuple[List[str], List[str], List[str]]: A tuple of lists indicating\n            added, changed, and removed groups by name.\n        Raises:\n            RPCError: Raised if the operation fails.\n        \"\"\"\nc = self._config_file_parser()\nc[f\"program:{program}\"] = {\"command\": command}\ntry:\nwith open(self._config_filename(), \"w\") as f:\nc.write(f)\nreturn self._reload_config()\nexcept Exception as e:\nraise RPCError(SupervisorFaults.FAILED, str(e)) from e\ndef set_command(\nself, program: str, command_or_section: str | dict[str, str]\n) -&gt; tuple[list[str], list[str], list[str]]:\n\"\"\"\n        Sets the command for a specified program or a section in the configuration file.\n        Example:\n            set_command('my_program', 'ls -la')\n            set_command('my_program', {'command': 'ls -la', 'autostart': 'true'})\n        Args:\n            program (str): Name of the program.\n            command_or_section (Union[str, Dict[str, str]]): Either a string\n                representing the command or a dictionary representing\n                a section in the configuration.\n        Returns:\n            Tuple[List[str], List[str], List[str]]: A tuple of lists indicating\n                added, changed, and removed groups by name.\n        Raises:\n            RPCError: Raised if the operation fails or if the\n                function name is not whitelisted.\n        \"\"\"\nself._update(\"set_command\")\nif isinstance(command_or_section, str):\nreturn self._set_command(program, command_or_section)\nelse:\nreturn self._set_section(f\"program:{program}\", command_or_section)\ndef get_config(self) -&gt; dict[str, dict[str, str]]:\n\"\"\"\n        Retrieves the current configuration.\n        Returns:\n            Dict[str, Dict[str, str]]: The current configuration as a dictionary.\n        Raises:\n            RPCError: Raised if the operation fails or if the\n                function name is not whitelisted.\n        \"\"\"\nself._update(\"get_config\")\nreturn self._config_file_dict()\ndef _set_section(\nself, section: str, settings: dict[str, str]\n) -&gt; tuple[list[str], list[str], list[str]]:\n\"\"\"\n        Sets a section in the configuration file with provided settings.\n        Args:\n            section (str): Name of the section (e.g., program:my_program).\n            settings (Dict[str, str]): Settings for the section.\n        Returns:\n            Tuple[List[str], List[str], List[str]]: A tuple of lists indicating\n            added, changed, and removed groups by name.\n        Raises:\n            RPCError: Raised if the operation fails.\n        \"\"\"\nc = self._config_file_parser()\nc[section] = settings\ntry:\nwith open(self._config_filename(), \"w\") as f:\nc.write(f)\nreturn self._reload_config()\nexcept Exception as e:\nraise RPCError(SupervisorFaults.FAILED, str(e)) from e\ndef _reload_config(self) -&gt; tuple[list[str], list[str], list[str]]:\n\"\"\"\n        Reloads the configuration and returns the changes.\n        Returns:\n            Tuple[List[str], List[str], List[str]]: A tuple of lists indicating\n            added, changed, and removed groups by name.\n        Raises:\n            RPCError: Raised if the operation fails.\n        \"\"\"\ntry:\nself.supervisord.options.process_config(do_usage=False)\nexcept ValueError as msg:\nraise RPCError(SupervisorFaults.CANT_REREAD, msg) from msg\nadded: list[ProcessGroupConfig] = []\nchanged: list[ProcessGroupConfig] = []\nremoved: list[ProcessGroupConfig] = []\nadded, changed, removed = self.supervisord.diff_to_active()\nadded_group_titles: list[str] = [group.name for group in added]\nchanged_group_titles: list[str] = [group.name for group in changed]\nremoved_group_titles: list[str] = [group.name for group in removed]\nreturn added_group_titles, changed_group_titles, removed_group_titles\ndef get_program_info(self, program: str) -&gt; dict[str, Any]:\n\"\"\"\n        Retrieves information about a specific program.\n        Args:\n            program (str): Name of the program.\n        Returns:\n            Dict[str, Any]: Dictionary containing information about\n                the specified program.\n        Raises:\n            RPCError: Raised if the operation fails or if the function\n                name is not whitelisted.\n        \"\"\"\nself._update(\"get_program_info\")\nreturn self.supervisord.getProcessInfo(program)\ndef start_program(self, program: str) -&gt; Literal[True]:\n\"\"\"\n        Starts a specific program.\n        Args:\n            program (str): Name of the program to start.\n        Returns:\n            bool: True if the program was started successfully.\n        Raises:\n            RPCError: Raised if the operation fails or if the function\n                name is not whitelisted.\n        \"\"\"\nself._update(\"start_program\")\ntry:\nself.supervisord.startProcess(program)\nexcept Exception as e:\nraise RPCError(SupervisorFaults.FAILED, str(e)) from e\nreturn True\ndef stop_program(self, program: str) -&gt; Literal[True]:\n\"\"\"\n        Stops a specific program.\n        Args:\n            program (str): Name of the program to stop.\n        Returns:\n            Union[str, bool]: Either a string indicating a failure or\n            True for successful stop.\n        Raises:\n            RPCError: Raised if the operation fails or if the\n                function name is not whitelisted.\n        \"\"\"\nself._update(\"stop_program\")\ntry:\nself.supervisord.stopProcess(program)\nexcept Exception as e:\nraise RPCError(SupervisorFaults.FAILED, str(e)) from e\nreturn True\ndef _set_config(\nself, config: dict[str, dict[str, str]]\n) -&gt; tuple[list[str], list[str], list[str]]:\n\"\"\"\n        Internal method to set the entire configuration.\n        :param config: New configuration as a dictionary.\n        :return: Result of the operation: List of Lists with the names (str)\n        of added, changed and removed groups.\n        \"\"\"\nc = UnhosedConfigParser(interpolation=None)\nc.read_dict(config)\ntry:\nwith open(self._config_filename(), \"w\") as f:\nc.write(f)\nreturn self._reload_config()\nexcept Exception as e:\nraise RPCError(SupervisorFaults.FAILED, str(e)) from e\ndef set_config(\nself, config: dict[str, dict[str, str]]\n) -&gt; tuple[list[str], list[str], list[str]]:\n\"\"\"\n        Set the entire configuration.\n        :param config: New configuration as a dictionary.\n        :return: Result of the operation: List of Lists with the names (str)\n        of added, changed and removed groups.\n        \"\"\"\nself._update(\"set_config\")\nreturn self._set_config(config)\n</code></pre>"},{"location":"rpcinterface_reference/#supervisor_cfg.rpcinterface.CfgNamespaceRPCInterface.__init__","title":"<code>__init__(supervisord, whitelist=[])</code>","text":"<p>Initializes the CfgNamespaceRPCInterface class.</p> <p>Parameters:</p> Name Type Description Default <code>supervisord</code> <p>Supervisor daemon instance.</p> required <code>whitelist</code> <code>List[str]</code> <p>List of whitelisted function names. Defaults to empty list.</p> <code>[]</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>Raised if whitelist is not a list of strings.</p> Source code in <code>supervisor_cfg/rpcinterface.py</code> <pre><code>def __init__(self, supervisord, whitelist: list[str] = []) -&gt; None:\n\"\"\"\n    Initializes the CfgNamespaceRPCInterface class.\n    Args:\n        supervisord: Supervisor daemon instance.\n        whitelist (List[str], optional): List of whitelisted\n            function names. Defaults to empty list.\n    Raises:\n        TypeError: Raised if whitelist is not a list of strings.\n    \"\"\"\nself.supervisord = supervisord\nself._whitelist = list_of_strings(whitelist)\n</code></pre>"},{"location":"rpcinterface_reference/#supervisor_cfg.rpcinterface.CfgNamespaceRPCInterface.get_config","title":"<code>get_config()</code>","text":"<p>Retrieves the current configuration.</p> <p>Returns:</p> Type Description <code>dict[str, dict[str, str]]</code> <p>Dict[str, Dict[str, str]]: The current configuration as a dictionary.</p> <p>Raises:</p> Type Description <code>RPCError</code> <p>Raised if the operation fails or if the function name is not whitelisted.</p> Source code in <code>supervisor_cfg/rpcinterface.py</code> <pre><code>def get_config(self) -&gt; dict[str, dict[str, str]]:\n\"\"\"\n    Retrieves the current configuration.\n    Returns:\n        Dict[str, Dict[str, str]]: The current configuration as a dictionary.\n    Raises:\n        RPCError: Raised if the operation fails or if the\n            function name is not whitelisted.\n    \"\"\"\nself._update(\"get_config\")\nreturn self._config_file_dict()\n</code></pre>"},{"location":"rpcinterface_reference/#supervisor_cfg.rpcinterface.CfgNamespaceRPCInterface.get_config_filename","title":"<code>get_config_filename()</code>","text":"<p>Retrieves the absolute path of the configuration file.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Absolute path of the configuration file.</p> Source code in <code>supervisor_cfg/rpcinterface.py</code> <pre><code>def get_config_filename(self) -&gt; str:\n\"\"\"\n    Retrieves the absolute path of the configuration file.\n    Returns:\n        str: Absolute path of the configuration file.\n    \"\"\"\nself._update(\"get_config_filename\")\nreturn self._config_filename()\n</code></pre>"},{"location":"rpcinterface_reference/#supervisor_cfg.rpcinterface.CfgNamespaceRPCInterface.get_program_info","title":"<code>get_program_info(program)</code>","text":"<p>Retrieves information about a specific program.</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>str</code> <p>Name of the program.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing information about the specified program.</p> <p>Raises:</p> Type Description <code>RPCError</code> <p>Raised if the operation fails or if the function name is not whitelisted.</p> Source code in <code>supervisor_cfg/rpcinterface.py</code> <pre><code>def get_program_info(self, program: str) -&gt; dict[str, Any]:\n\"\"\"\n    Retrieves information about a specific program.\n    Args:\n        program (str): Name of the program.\n    Returns:\n        Dict[str, Any]: Dictionary containing information about\n            the specified program.\n    Raises:\n        RPCError: Raised if the operation fails or if the function\n            name is not whitelisted.\n    \"\"\"\nself._update(\"get_program_info\")\nreturn self.supervisord.getProcessInfo(program)\n</code></pre>"},{"location":"rpcinterface_reference/#supervisor_cfg.rpcinterface.CfgNamespaceRPCInterface.set_command","title":"<code>set_command(program, command_or_section)</code>","text":"<p>Sets the command for a specified program or a section in the configuration file.</p> Example <p>set_command('my_program', 'ls -la') set_command('my_program', {'command': 'ls -la', 'autostart': 'true'})</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>str</code> <p>Name of the program.</p> required <code>command_or_section</code> <code>Union[str, Dict[str, str]]</code> <p>Either a string representing the command or a dictionary representing a section in the configuration.</p> required <p>Returns:</p> Type Description <code>tuple[list[str], list[str], list[str]]</code> <p>Tuple[List[str], List[str], List[str]]: A tuple of lists indicating added, changed, and removed groups by name.</p> <p>Raises:</p> Type Description <code>RPCError</code> <p>Raised if the operation fails or if the function name is not whitelisted.</p> Source code in <code>supervisor_cfg/rpcinterface.py</code> <pre><code>def set_command(\nself, program: str, command_or_section: str | dict[str, str]\n) -&gt; tuple[list[str], list[str], list[str]]:\n\"\"\"\n    Sets the command for a specified program or a section in the configuration file.\n    Example:\n        set_command('my_program', 'ls -la')\n        set_command('my_program', {'command': 'ls -la', 'autostart': 'true'})\n    Args:\n        program (str): Name of the program.\n        command_or_section (Union[str, Dict[str, str]]): Either a string\n            representing the command or a dictionary representing\n            a section in the configuration.\n    Returns:\n        Tuple[List[str], List[str], List[str]]: A tuple of lists indicating\n            added, changed, and removed groups by name.\n    Raises:\n        RPCError: Raised if the operation fails or if the\n            function name is not whitelisted.\n    \"\"\"\nself._update(\"set_command\")\nif isinstance(command_or_section, str):\nreturn self._set_command(program, command_or_section)\nelse:\nreturn self._set_section(f\"program:{program}\", command_or_section)\n</code></pre>"},{"location":"rpcinterface_reference/#supervisor_cfg.rpcinterface.CfgNamespaceRPCInterface.set_config","title":"<code>set_config(config)</code>","text":"<p>Set the entire configuration.</p> <p>:param config: New configuration as a dictionary. :return: Result of the operation: List of Lists with the names (str) of added, changed and removed groups.</p> Source code in <code>supervisor_cfg/rpcinterface.py</code> <pre><code>def set_config(\nself, config: dict[str, dict[str, str]]\n) -&gt; tuple[list[str], list[str], list[str]]:\n\"\"\"\n    Set the entire configuration.\n    :param config: New configuration as a dictionary.\n    :return: Result of the operation: List of Lists with the names (str)\n    of added, changed and removed groups.\n    \"\"\"\nself._update(\"set_config\")\nreturn self._set_config(config)\n</code></pre>"},{"location":"rpcinterface_reference/#supervisor_cfg.rpcinterface.CfgNamespaceRPCInterface.start_program","title":"<code>start_program(program)</code>","text":"<p>Starts a specific program.</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>str</code> <p>Name of the program to start.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>Literal[True]</code> <p>True if the program was started successfully.</p> <p>Raises:</p> Type Description <code>RPCError</code> <p>Raised if the operation fails or if the function name is not whitelisted.</p> Source code in <code>supervisor_cfg/rpcinterface.py</code> <pre><code>def start_program(self, program: str) -&gt; Literal[True]:\n\"\"\"\n    Starts a specific program.\n    Args:\n        program (str): Name of the program to start.\n    Returns:\n        bool: True if the program was started successfully.\n    Raises:\n        RPCError: Raised if the operation fails or if the function\n            name is not whitelisted.\n    \"\"\"\nself._update(\"start_program\")\ntry:\nself.supervisord.startProcess(program)\nexcept Exception as e:\nraise RPCError(SupervisorFaults.FAILED, str(e)) from e\nreturn True\n</code></pre>"},{"location":"rpcinterface_reference/#supervisor_cfg.rpcinterface.CfgNamespaceRPCInterface.stop_program","title":"<code>stop_program(program)</code>","text":"<p>Stops a specific program.</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>str</code> <p>Name of the program to stop.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>Union[str, bool]: Either a string indicating a failure or</p> <code>Literal[True]</code> <p>True for successful stop.</p> <p>Raises:</p> Type Description <code>RPCError</code> <p>Raised if the operation fails or if the function name is not whitelisted.</p> Source code in <code>supervisor_cfg/rpcinterface.py</code> <pre><code>def stop_program(self, program: str) -&gt; Literal[True]:\n\"\"\"\n    Stops a specific program.\n    Args:\n        program (str): Name of the program to stop.\n    Returns:\n        Union[str, bool]: Either a string indicating a failure or\n        True for successful stop.\n    Raises:\n        RPCError: Raised if the operation fails or if the\n            function name is not whitelisted.\n    \"\"\"\nself._update(\"stop_program\")\ntry:\nself.supervisord.stopProcess(program)\nexcept Exception as e:\nraise RPCError(SupervisorFaults.FAILED, str(e)) from e\nreturn True\n</code></pre>"},{"location":"rpcinterface_reference/#supervisor_cfg.rpcinterface.ExtendedSupervisorStates","title":"<code>ExtendedSupervisorStates</code>","text":"<p>             Bases: <code>SupervisorStates</code></p> <p>Extended Supervisor states for custom behavior.</p> <p>Attributes:</p> Name Type Description <code>NOT_IN_WHITELIST</code> <code>int</code> <p>Represents a state where an operation is not whitelisted.</p> Source code in <code>supervisor_cfg/rpcinterface.py</code> <pre><code>class ExtendedSupervisorStates(SupervisorStates):\n\"\"\"\n    Extended Supervisor states for custom behavior.\n    Attributes:\n        NOT_IN_WHITELIST (int): Represents a state\n            where an operation is not whitelisted.\n    \"\"\"\nNOT_IN_WHITELIST = 1001\n</code></pre>"}]}